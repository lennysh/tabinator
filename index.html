<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link Launcher</title>
    <!-- 1. Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. js-yaml library to parse the YAML file -->
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    
    <style>
        body {
            /* This is Tailwind's gray-900 and gray-100 */
            background-color: #111827; 
            color: #f3f4f6;
        }
    </style>
    
    <style type="text/tailwindcss">
        .btn {
            @apply px-4 py-2 rounded-lg text-white font-semibold transition-all duration-200 ease-in-out;
        }
        .btn-blue {
            @apply bg-blue-600 hover:bg-blue-700 shadow-md;
        }
        body {
            @apply font-sans min-h-screen;
        }
        
        .tag-btn {
            @apply px-3 py-1 text-sm rounded-full cursor-pointer transition-all duration-150 ease-in-out;
        }
        .tag-btn-inactive {
            @apply bg-gray-700 text-gray-300 hover:bg-gray-600;
        }
        .tag-btn-active {
            /* Groups are active with Indigo */
            @apply bg-indigo-600 text-white font-medium ring-2 ring-indigo-400 ring-offset-2 ring-offset-gray-900;
        }
        .tag-btn-active-tag {
             /* Tags are active with Blue */
             @apply bg-blue-600 text-white font-medium ring-2 ring-blue-400 ring-offset-2 ring-offset-gray-900;
        }
        .tag-btn-hidden {
            @apply hidden;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">

    <div class="container max-w-7xl mx-auto p-4 md:p-8">
        
        <header class="mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Link Launcher</h1>
            <p class="text-lg text-gray-400 mb-6">Your self-hosted link dashboard.</p>
            
            <input
                type="search"
                id="search-bar"
                placeholder="Search titles, names, or URLs..."
                class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />

            <div class="mt-4">
                <div>
                    <label for="sort-select" class="block text-sm font-medium text-gray-400">Sort links by:</label>
                    <select id="sort-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-gray-700 border-gray-600 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md text-white">
                        <option value="custom">Custom Order (default)</option>
                        <option value="az">A-Z (by name)</option>
                    </select>
                </div>
            </div>
            
        </header>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
            
            <!-- Left Column for main content -->
            <div class="md:col-span-3">
                
                <div class="mb-8">
                    <button id="open-all-filtered-btn" class="btn btn-blue w-full">
                        Open All Filtered Links
                    </button>
                </div>
        
                <div class="bg-yellow-800 border-l-4 border-yellow-500 text-yellow-100 p-4 rounded-lg mb-8" role="alert">
                    <p class="font-bold">Heads up!</p>
                    <p>Your browser's pop-up blocker will likely prevent the "Open All" button from working. Please **allow pop-ups** from this site (`http://localhost:8080`) for the feature to work correctly.</p>
                </div>
        
                <div id="loading-state" class="text-center text-gray-400 text-lg">
                    <p>Loading `links.yaml`...</p>
                </div>
        
                <div id="error-state" class="hidden bg-red-800 text-red-100 p-4 rounded-lg">
                    <p class="font-bold">Error loading config:</p>
                    <p id="error-message"></p>
                </div>
        
                <div id="no-results" class="hidden text-center text-gray-400 text-lg">
                    <p>No results found.</p>
                </div>
        
                <main id="app-container" class="hidden bg-gray-800 shadow-lg rounded-lg overflow-hidden">
                    <!-- Link list will be rendered here -->
                </main>

            </div>

            <!-- Right Column for Tag Sidebar -->
            <div class="md:col-span-1">
                <div class="sticky top-8 space-y-6">
                    <div id="group-filter-container" class="hidden bg-gray-800 rounded-lg p-4">
                        <label class="block text-sm font-medium text-gray-400 mb-3">Filter by Groups:</label>
                        <div id="group-pills-container" class="flex flex-wrap gap-2 max-h-[35vh] overflow-y-auto">
                            <!-- Group buttons will be dynamically inserted here -->
                        </div>
                    </div>
                    
                    <div id="tag-filter-container" class="hidden bg-gray-800 rounded-lg p-4">
                        <label class="block text-sm font-medium text-gray-400 mb-3">Filter by Tags:</label>
                        <div id="tag-pills-container" class="flex flex-wrap gap-2 max-h-[35vh] overflow-y-auto">
                            <!-- Tag buttons will be dynamically inserted here -->
                        </div>
                    </div>
                </div>
            </div>

        </div> <!-- End 2-column grid -->

    </div>

    <script>
        // Store the parsed data globally
        let linkData = null; // Will hold { links: [], groups: [] }
        let currentlyFilteredLinks = [];
        
        // Store filter states globally
        let allTags = new Set();
        let activeTags = new Set();
        let allGroups = new Set(); // Will hold group *names*
        let activeGroups = new Set();
        
        let currentSort = 'custom';
        let currentQuery = '';
        
        let tagButtonElements = {};
        let groupButtonElements = {};

        document.addEventListener('DOMContentLoaded', () => {
            loadAndRenderLinks();
            
            document.getElementById('open-all-filtered-btn').addEventListener('click', handleOpenAllFiltered);
            document.getElementById('tag-pills-container').addEventListener('click', handleTagClick);
            document.getElementById('group-pills-container').addEventListener('click', handleGroupClick);
        });

        /**
         * Fetches and parses the links.yaml file, then renders the app
         */
        async function loadAndRenderLinks() {
            const loadingEl = document.getElementById('loading-state');
            const errorEl = document.getElementById('error-state');
            const errorMsgEl = document.getElementById('error-message');
            const appEl = document.getElementById('app-container');

            const searchInput = document.getElementById('search-bar');
            const sortSelect = document.getElementById('sort-select');

            // Restore saved values from localStorage
            currentQuery = localStorage.getItem('linkLauncherQuery') || '';
            currentSort = localStorage.getItem('linkLauncherSort') || 'custom';
            activeTags = new Set(JSON.parse(localStorage.getItem('linkLauncherTags') || '[]'));
            activeGroups = new Set(JSON.parse(localStorage.getItem('linkLauncherGroups') || '[]'));

            // Apply restored values to inputs
            searchInput.value = currentQuery;
            sortSelect.value = currentSort;

            try {
                // 1. Fetch the YAML file with cache-busting
                const response = await fetch('links.yaml', {
                    cache: 'no-store',
                    headers: { 'Cache-Control': 'no-cache', 'Pragma': 'no-cache' }
                });
                if (!response.ok) {
                    throw new Error(`Failed to fetch links.yaml (Status: ${response.status})`);
                }
                const yamlText = await response.text();

                // 2. Parse the YAML
                linkData = jsyaml.load(yamlText);

                if (!linkData || !linkData.links) {
                    throw new Error("YAML file is valid but doesn't contain a 'links' list.");
                }
                // Ensure linkData.groups exists, even if empty
                if (!linkData.groups) {
                    linkData.groups = [];
                }


                // 3. Discover all tags and groups
                allTags.clear();
                allGroups.clear();
                linkData.links.forEach(link => {
                    link.tags?.forEach(tag => allTags.add(tag));
                });
                // Get group names from the group definitions
                linkData.groups.forEach(group => {
                    if (group.name) {
                        allGroups.add(group.name);
                    }
                });
                
                // 4. Create tag and group pill elements ONCE
                createTagPills();
                createGroupPills();

                // 5. Render the application
                renderApp(); 

                // 6. Update UI state
                loadingEl.classList.add('hidden');
                appEl.classList.remove('hidden'); // This is now the <main> element

                // 7. Add event listeners
                searchInput.addEventListener('input', handleSearch);
                sortSelect.addEventListener('change', handleSort);

            } catch (error) {
                console.error("Error loading links:", error);
                errorMsgEl.textContent = error.message;
                loadingEl.classList.add('hidden');
                errorEl.classList.remove('hidden');
            }
        }
        
        /**
         * Creates all tag pill DOM elements one time on load
         */
        function createTagPills() {
            const tagContainer = document.getElementById('tag-pills-container');
            const tagFilterContainer = document.getElementById('tag-filter-container');
            tagContainer.innerHTML = '';
            tagButtonElements = {};
            
            if (allTags.size === 0) {
                tagFilterContainer.classList.add('hidden');
                return;
            }
            
            tagFilterContainer.classList.remove('hidden');
            const sortedTags = Array.from(allTags).sort((a, b) => a.localeCompare(b));
            
            sortedTags.forEach(tag => {
                const button = document.createElement('button');
                button.textContent = tag;
                button.setAttribute('data-tag', tag);
                tagContainer.appendChild(button);
                tagButtonElements[tag] = button;
            });
        }

        /**
         * Creates all group pill DOM elements one time on load
         */
        function createGroupPills() {
            const groupContainer = document.getElementById('group-pills-container');
            const groupFilterContainer = document.getElementById('group-filter-container');
            groupContainer.innerHTML = '';
            groupButtonElements = {};
            
            if (allGroups.size === 0) {
                groupFilterContainer.classList.add('hidden');
                return;
            }
            
            groupFilterContainer.classList.remove('hidden');
            // Sort by name from the allGroups Set
            const sortedGroups = Array.from(allGroups).sort((a, b) => a.localeCompare(b));
            
            sortedGroups.forEach(groupName => {
                const button = document.createElement('button');
                button.textContent = groupName;
                button.setAttribute('data-group', groupName);
                groupContainer.appendChild(button);
                groupButtonElements[groupName] = button;
            });
        }
        
        /**
         * Updates the visibility and state of tag pills based on filtered links
         */
        function updateTagPills(availableTags) {
             for (const tag in tagButtonElements) {
                const button = tagButtonElements[tag];
                const isActive = activeTags.has(tag);
                const isAvailable = availableTags.has(tag);

                if (isActive) {
                    // Added specific active class for tags
                    button.className = 'tag-btn tag-btn-active-tag';
                } else if (isAvailable) {
                    button.className = 'tag-btn tag-btn-inactive';
                } else {
                    button.className = 'tag-btn tag-btn-hidden';
                }
            }
        }

        /**
         * Updates the visibility and state of group pills based on filtered links
         */
        function updateGroupPills(availableGroups) {
             for (const groupName in groupButtonElements) {
                const button = groupButtonElements[groupName];
                const isActive = activeGroups.has(groupName);
                const isAvailable = availableGroups.has(groupName);

                if (isActive) {
                    // Active class for groups
                    button.className = 'tag-btn tag-btn-active';
                } else if (isAvailable) {
                    button.className = 'tag-btn tag-btn-inactive';
                } else {
                    button.className = 'tag-btn tag-btn-hidden';
                }
            }
        }
        
        /**
         * NEW: Helper to check if a link property matches ANY keyword in a list.
         * @param {string[]} list - The list of keywords (e.g., ['github', 'ansible'])
         * @param {string} linkProp - The property of the link to check ('name', 'url', 'tags')
         * @param {object} link - The link object
         */
        function checkList(list, linkProp, link) {
            if (!list || list.length === 0) return false; // No rules, so no match

            if (linkProp === 'tags') {
                const linkTags = new Set(link.tags || []);
                // Does ANY tag in the list exist in the link's tags? (OR)
                return list.some(tag => linkTags.has(tag));
            } else {
                // 'name' or 'url'
                const linkValue = (link[linkProp] || '').toLowerCase();
                // Does ANY keyword in the list exist in the link's value? (OR)
                return list.some(keyword => linkValue.includes(keyword.toLowerCase()));
            }
        }


        /**
         * NEW: Revamped helper function to check if a link matches a "smart group" definition
         */
        function linkMatchesGroup(link, groupDef) {
            
            // 1. Check INCLUDES (must match ALL blocks)
            const includeBlocks = groupDef.include || [];
            const allIncludesMatch = includeBlocks.every(block => {
                // block = { tags: ['a'], names: ['b'] }
                // Must match AT LEAST ONE rule in the block (OR)
                return checkList(block.tags, 'tags', link) ||
                       checkList(block.names, 'name', link) ||
                       checkList(block.urls, 'url', link);
            });

            if (!allIncludesMatch) return false;

            // 2. Check EXCLUDES (must match NO blocks)
            const excludeBlocks = groupDef.exclude || [];
            const anyExcludeMatches = excludeBlocks.some(block => {
                // block = { tags: ['d'] }
                // Must match AT LEAST ONE rule in the block (OR)
                return checkList(block.tags, 'tags', link) ||
                       checkList(block.names, 'name', link) ||
                       checkList(block.urls, 'url', link);
            });

            if (anyExcludeMatches) return false;
            
            // 3. If passed both, it's a match
            return true;
        }

        /**
         * Renders the link groups and cards based on current filters
         */
        function renderApp() {
            if (!linkData || !linkData.links) return;

            const appEl = document.getElementById('app-container');
            const noResultsEl = document.getElementById('no-results');
            appEl.innerHTML = ''; // Clear previous content
            
            // 1. Filter by Search Query
            let searchFilteredLinks = [...linkData.links];
            if (currentQuery) {
                searchFilteredLinks = searchFilteredLinks.filter(link => {
                    const nameMatch = (link.name || '').toLowerCase().includes(currentQuery);
                    const urlMatch = (link.url || '').toLowerCase().includes(currentQuery);
                    return nameMatch || urlMatch;
                });
            }
            
            // 2. Filter by Active Tags (AND logic)
            let tagsFilteredLinks = [...searchFilteredLinks];
            if (activeTags.size > 0) {
                tagsFilteredLinks = tagsFilteredLinks.filter(link => {
                    if (!link.tags || !Array.isArray(link.tags)) return false;
                    return Array.from(activeTags).every(activeTag => link.tags.includes(activeTag));
                });
            }

            // 3. Filter by Active Groups (OR logic on definitions)
            let finalFilteredLinks = [...tagsFilteredLinks];
            if (activeGroups.size > 0) {
                const activeGroupDefs = linkData.groups.filter(g => activeGroups.has(g.name));
                
                finalFilteredLinks = tagsFilteredLinks.filter(link => {
                    // Return true if the link matches *any* of the active group definitions
                    return activeGroupDefs.some(groupDef => linkMatchesGroup(link, groupDef));
                });
            }
            
            // 4. Calculate available tags and groups
            // Calculate which groups are available *after* search+tag filters
            const availableGroups = new Set();
            const allGroupDefs = linkData.groups || [];
            tagsFilteredLinks.forEach(link => {
                allGroupDefs.forEach(groupDef => {
                    if (availableGroups.has(groupDef.name)) return; // Already know this group is available
                    if (linkMatchesGroup(link, groupDef)) {
                        availableGroups.add(groupDef.name);
                    }
                });
            });

            // Calculate which groups-filtered links to use for tag faceting
            let groupsFilteredLinks = [...searchFilteredLinks];
            if (activeGroups.size > 0) {
                 const activeGroupDefs = linkData.groups.filter(g => activeGroups.has(g.name));
                 groupsFilteredLinks = searchFilteredLinks.filter(link => {
                    return activeGroupDefs.some(groupDef => linkMatchesGroup(link, groupDef));
                });
            }

            // Calculate available tags *after* search+group filters
            const availableTags = new Set();
            groupsFilteredLinks.forEach(link => {
                link.tags?.forEach(tag => availableTags.add(tag));
            });
            
            // 5. Update the tag and group pill UI
            updateTagPills(availableTags);
            updateGroupPills(availableGroups);

            // 6. Sort the filtered links
            let sortedLinks = [...finalFilteredLinks];
            if (currentSort === 'az') {
                sortedLinks.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
            }
            
            // 7. Store the filtered links for the "Open All" button
            currentlyFilteredLinks = sortedLinks;
            
            // 8. Render the final list
            if (sortedLinks.length > 0) {
                renderLinkList(sortedLinks);
                noResultsEl.classList.add('hidden');
                appEl.classList.remove('hidden'); // Show the <main> element
            } else {
                noResultsEl.classList.remove('hidden');
                appEl.classList.add('hidden'); // Hide the <main> element
            }
            
            // 9. Update the "Open All" button text
            const openAllBtn = document.getElementById('open-all-filtered-btn');
            openAllBtn.textContent = `Open All Filtered Links (${currentlyFilteredLinks.length})`;
            openAllBtn.disabled = currentlyFilteredLinks.length === 0;
            if (openAllBtn.disabled) {
                openAllBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                openAllBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }
        
        /**
         * Renders the final list of links into the app container
         */
        function renderLinkList(links) {
            const appEl = document.getElementById('app-container');
            
            const getHostname = (url) => {
                try { return new URL(url).hostname; } catch (e) { return 'example.com'; }
            };
            
            const linksHtml = links.map(link => {
                
                let tagsHtml = '';
                if (link.tags && Array.isArray(link.tags)) {
                    const sortedLinkTags = [...link.tags].sort((a, b) => a.localeCompare(b));
                    tagsHtml = sortedLinkTags.map(tag => 
                        `<span class="bg-gray-600 text-gray-300 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">${tag}</span>`
                    ).join('');
                }

                return `
                <li class="flex items-center p-3 hover:bg-gray-700 transition-colors duration-150">
                    <img 
                        src="https://www.google.com/s2/favicons?domain=${getHostname(link.url)}&sz=32" 
                        alt="favicon" 
                        class="w-5 h-5 mr-3 rounded-sm flex-shrink-0"
                        onerror="this.style.display='none'"
                    >
                    <div class="flex-1 truncate min-w-0">
                        <a href="${link.url}" target="_blank" rel="noopener noreferrer" 
                           class="text-blue-400 hover:text-blue-300 text-base truncate block" 
                           title="${link.name}">
                            ${link.name || 'Missing Name'}
                        </a>
                        <p class="text-gray-400 text-xs truncate" title="${link.url}">
                            ${link.url || 'Missing URL'}
                        </p>
                        <div class="mt-2 flex flex-wrap gap-1 ${tagsHtml ? '' : 'hidden'}">
                            ${tagsHtml}
                        </div>
                    </div>
                </li>
                `;
            }).join('');
            
            appEl.innerHTML = `<ul class="divide-y divide-gray-700">${linksHtml}</ul>`;
        }

        /**
         * Handles search input by re-rendering the app
         */
        function handleSearch(event) {
            currentQuery = event.target.value.toLowerCase();
            localStorage.setItem('linkLauncherQuery', currentQuery);
            renderApp();
        }

        /**
         * Handles sort selection change by re-rendering the app
         */
        function handleSort(event) {
            currentSort = event.target.value;
            localStorage.setItem('linkLauncherSort', currentSort);
            renderApp();
        }
        
        /**
         * Handles tag button clicks for filtering
         */
        function handleTagClick(event) {
            const target = event.target.closest('.tag-btn');
            if (!target) return;
            
            const tag = target.getAttribute('data-tag');
            if (activeTags.has(tag)) {
                activeTags.delete(tag);
            } else {
                activeTags.add(tag);
            }
            
            localStorage.setItem('linkLauncherTags', JSON.stringify(Array.from(activeTags)));
            renderApp();
        }

        /**
         * Handles group button clicks for filtering
         */
        function handleGroupClick(event) {
            const target = event.target.closest('.tag-btn');
            if (!target) return;
            
            const group = target.getAttribute('data-group');
            if (activeGroups.has(group)) {
                activeGroups.delete(group);
            } else {
                activeGroups.add(group);
            }
            
            localStorage.setItem('linkLauncherGroups', JSON.stringify(Array.from(activeGroups)));
            renderApp();
        }

        /**
         * Handles click on the main "Open All Filtered" button
         */
        function handleOpenAllFiltered() {
            if (currentlyFilteredLinks && currentlyFilteredLinks.length > 0) {
                console.log(`Opening ${currentlyFilteredLinks.length} filtered links...`);
                currentlyFilteredLinks.forEach((link, i) => {
                    window.open(link.url, '_blank');
                });
            } else {
                console.warn('No filtered links to open.');
            }
        }

    </script>
</body>
</html>

